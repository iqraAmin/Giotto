% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustering.R
\name{labelTransfer}
\alias{labelTransfer}
\alias{labelTransfer,giotto,giotto-method}
\alias{labelTransfer,giotto,missing-method}
\title{Transfer labels/annotations between sets of data via similarity
voting}
\usage{
\S4method{labelTransfer}{giotto,giotto}(
  x,
  y,
  labels,
  k = 10,
  name = paste0("trnsfr_", labels),
  integration_method = c("none", "harmony"),
  prob = TRUE,
  reduction = "cells",
  reduction_method = "pca",
  reduction_name = "pca",
  dimensions_to_use = 1:10,
  spat_unit = NULL,
  feat_type = NULL,
  return_gobject = TRUE,
  ...
)

\S4method{labelTransfer}{giotto,missing}(
  x,
  spat_unit = NULL,
  feat_type = NULL,
  source_cell_ids,
  target_cell_ids,
  labels,
  k = 10,
  name = paste0("trnsfr_", labels),
  prob = TRUE,
  reduction = "cells",
  reduction_method = "pca",
  reduction_name = "pca",
  dimensions_to_use = 1:10,
  return_gobject = TRUE,
  ...
)
}
\arguments{
\item{x}{target object}

\item{y}{source object}

\item{labels}{metadata column in source with labels to transfer}

\item{k}{number of k-neighbors to train a KNN classifier}

\item{name}{metadata column in target to apply the full set of labels to}

\item{integration_method}{character. Integration method to use when
transferring labels. Options are "none" (default) and "harmony". See section
below for more info and params.}

\item{prob}{output knn probabilities together with label predictions}

\item{reduction}{reduction on cells or features (default = "cells")}

\item{reduction_method}{shared reduction method (default = "pca" space)}

\item{reduction_name}{name of shared reduction space (default name = "pca")}

\item{dimensions_to_use}{dimensions to use in shared reduction space
(default = 1:10)}

\item{spat_unit}{spatial unit. A character vector of 2 can also be passed
for x (1) and y (2). Setting defaults with \code{activeSpatUnit()} may be easier}

\item{feat_type}{feature type. A character vector of 2 can also be passed
for x (1) and y (2). Setting defaults with \code{activeFeatType()} may be easier}

\item{...}{
  Arguments passed on to \code{\link[FNN:knn]{FNN::knn}}
  \describe{
    \item{\code{algorithm}}{nearest neighbor search algorithm.}
  }}

\item{source_cell_ids}{cell/spatial IDs with the source labels to transfer}

\item{target_cell_ids}{cell/spatial IDs to transfer the labels to.
IDs from \code{source_cell_ids} are always included as well.}
}
\value{
object \code{x} with new transferred labels added to metadata. If
running on \code{x} and \code{y} objects, \code{integration_method = "harmony"},
\code{plot_join_labels = TRUE}, and \code{return_plot = TRUE} is set, output will
be instead a named list of \code{gobject} (updated \code{x}), and \code{label_source_plot}
and \code{label_target_plot} \code{ggplot2} objects
}
\description{
When two sets of data share an embedding space, transfer the labels from
one of the sets to the other based on KNN similarity voting in that space.
}
\details{
This function trains a KNN classifier with \code{\link[FNN:knn]{FNN::knn()}}.
The training data is from object \code{y} or \code{source_cell_ids} subset in \code{x} and
uses existing annotations within the cell metadata.
Cells without annotation/labels from \code{x} or \code{target_cell_ids} subset in \code{x}
will receive predicted labels (and optional probabilities when
\code{prob = TRUE}).

\strong{IMPORTANT} This projection assumes that you're using the same dimension
reduction space (e.g. PCA) and number of dimensions (e.g. first 10 PCs) to
train the KNN classifier as you used to create the initial
annotations/labels in the source Giotto object.

This function can allow you to work with very big data as you can predict
cell labels on a smaller & subsetted Giotto object and then project the cell
labels to the remaining cells in the target Giotto object. It can also be
used to transfer labels from one set of annotated data to another dataset
based on expression similarity after joining and integrating.
}
\section{integration_method}{
When running \code{labelTranfer()} on two \code{giotto} objects, an integration
pipeline can also be run to align the two datasets together before the
transfer. \code{integration_method = "harmony"} will make a temporary joined
object on shared features, filter to remove 0 values, run PCA, then harmony
integration, before performing the label transfer from \code{y} to \code{x} on the
integrated harmony embedding space. Additional params that can be used with
this method are:\cr
\itemize{
\item \code{source_cell_ids} - character. subset of \code{y} cells to use
\item \code{target_cell_ids} - character. subset of \code{x} cells to use
\item \code{expression_values} - character. expression values in \code{x} and \code{y} to use
to generate combined space. Default = \code{"raw"}
\item \code{use_hvf} - logical. whether to calculate highly variable features to use
for PCA calculation. Default = \code{TRUE}, but setting \code{FALSE} is recommended if
any of \code{x} or \code{y} has roughly 1000 features or fewer
\item \code{plot_join_labels} - logical. Whether to plot source labels and final
labels in the joine object UMAP.
\item \code{normalize_params} - named list. Additional params to pass to
\code{normalizeGiotto()} if desired.
\item \code{pca_params} - named list. Additional params to pass to \code{runPCA()} if
desired.
\item \code{integration_params} - named list. Additional params to pass to
\code{runGiottoHarmony()} if desired.
\item \code{plot_params} - named list. Additional params to pass to \code{plotUMAP()} if
desired. Only relevant when \code{plot_join_labels = TRUE}
\item \code{verbose} - verbosity
}
}

\examples{
g <- GiottoData::loadGiottoMini("visium")
id_subset <- sample(spatIDs(g), 300)
n_pred <- nrow(pDataDT(g)) - 300

# transfer labels from one object to another ###################
g_small <- g[, id_subset]
# additional steps to get labels to transfer on smaller object...
g <- labelTransfer(g, g_small, labels = "leiden_clus")

# transfer labels between subsets of a single object ###########
g <- labelTransfer(g,
    label = "leiden_clus", source_cell_ids = id_subset, name = "knn_leiden2"
)
}
